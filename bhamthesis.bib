Automatically generated by Mendeley Desktop 1.16.1
Any changes to this file will be lost if it is regenerated by Mendeley.

BibTeX export options can be customized via Preferences -> BibTeX in Mendeley Desktop

@article{Matthews2009,
author = {Matthews, Jacob and Findler, Robert Bruce},
doi = {10.1145/1498926.1498930},
file = {:Users/jack/Desktop/FYP-citations/toplas09-mf.pdf:pdf},
isbn = {1595935754},
issn = {01640925},
journal = {ACM Transactions on Programming Languages and Systems},
keywords = {Operational semantics,interoperability},
number = {3},
pages = {1--44},
title = {{Operational semantics for multi-language programs}},
url = {http://dl.acm.org/citation.cfm?id=1498926.1498930},
volume = {31},
year = {2009}
}
@article{Fallis2013,
abstract = {Predicting the binding mode of flexible polypeptides to proteins is an important task that falls outside the domain of applicability of most small molecule and protein−protein docking tools. Here, we test the small molecule flexible ligand docking program Glide on a set of 19 non-$\alpha$-helical peptides and systematically improve pose prediction accuracy by enhancing Glide sampling for flexible polypeptides. In addition, scoring of the poses was improved by post-processing with physics-based implicit solvent MM- GBSA calculations. Using the best RMSD among the top 10 scoring poses as a metric, the success rate (RMSD ≤ 2.0 {\AA} for the interface backbone atoms) increased from 21{\%} with default Glide SP settings to 58{\%} with the enhanced peptide sampling and scoring protocol in the case of redocking to the native protein structure. This approaches the accuracy of the recently developed Rosetta FlexPepDock method (63{\%} success for these 19 peptides) while being over 100 times faster. Cross-docking was performed for a subset of cases where an unbound receptor structure was available, and in that case, 40{\%} of peptides were docked successfully. We analyze the results and find that the optimized polypeptide protocol is most accurate for extended peptides of limited size and number of formal charges, defining a domain of applicability for this approach.},
archivePrefix = {arXiv},
arxivId = {arXiv:1011.1669v3},
author = {Frost, R and Launchbury, J},
doi = {10.1017/CBO9781107415324.004},
eprint = {arXiv:1011.1669v3},
file = {:Users/jack/Library/Application Support/Mendeley Desktop/Downloaded/f29ec533751c1e259c6f8d4f897ced30adbe5a49.pdf:pdf},
isbn = {9788578110796},
issn = {1098-6596},
journal = {Journal of Chemical Information and Modeling},
keywords = {icle},
number = {9},
pages = {1689--1699},
pmid = {25246403},
title = {{Constructing Natural Language Interpreters in a Lazy Functional Language}},
url = {http://comjnl.oxfordjournals.org/content/32/2/108.full.pdf},
volume = {53},
year = {2013}
}
@article{Bash2015,
archivePrefix = {arXiv},
arxivId = {arXiv:1011.1669v3},
author = {Cartwright, Robert and Fagan, Mike},
doi = {10.1017/CBO9781107415324.004},
eprint = {arXiv:1011.1669v3},
file = {:Users/jack/Library/Application Support/Mendeley Desktop/Downloaded/09c2895f93905d11786c64f7c1eeaa9164f511a7.pdf:pdf},
isbn = {9788578110796},
issn = {1098-6596},
keywords = {icle},
pmid = {25246403},
title = {{Soft Typing}},
volume = {1},
year = {1991}
}
@article{Gronski2006,
author = {Gronski, Jessica and Knowles, Kenneth and Tomb, Aaron and Freund, Stephen N and Flanagan, Cormac},
file = {:Users/jack/Desktop/FYP-citations/gronski06sage.pdf:pdf},
journal = {Proceedings of the Scheme and Functional Programming Workshop},
pages = {93--104},
title = {{SAGE: Hybrid Checking for Flexible Specifications}},
year = {2006}
}
@article{Siek2013,
abstract = {Gradual typing enables a mixture of static and dynamic typ- ing within the same program. There are four properties that are desirable in a gradually-typed language: 1) the type system allows implicit conver- sions to and from the dynamic type so that values can easily pass between statically and dynamically-typed regions of code, 2) the overhead associ- ated with implicit conversions is low, 3) if one of these conversions fails, the guilty source location is blamed, and 4) statically-typed regions of code execute just as efficiently as code written in a statically-typed lan- guage. This paper presents the first design, monotonic objects, that has all four properties in the presence of mutable state. On the way to this design we develop guarded objects, a natural extension of earlier work that imposes some overhead on statically-typed regions of code},
author = {Siek, Jeremy G and Vitousek, Michael M and Bharadwaj, Shashank},
file = {:Users/jack/Desktop/FYP-citations/gtmo.pdf:pdf},
pages = {1--34},
title = {{Gradual Typing for Mutable Objects}},
year = {2013}
}
@article{Siek2007,
abstract = {Static and dynamic type systems have well-known strengths and weaknesses. In previous work we developed a gradual type system for a functional calculus named . Gradual typing provides the benefits of both static and dynamic checking in a single language by allowing the programmer to control whether a portion of the program is type checked at compile-time or run-time by adding or removing type annotations on variables. Several object-oriented scripting languages are preparing to add static checking. To support that work this paper develops , a gradual type system for object-based languages, extending the calculus of Abadi and Cardelli. Our primary contribution is to show that gradual typing and subtyping are orthogonal and can be combined in a principled fashion. We also develop a small-step semantics, provide a machine-checked proof of type safety, and improve the space efficiency of higher-order casts.},
author = {Siek, Jeremy and Taha, Walid},
doi = {10.1007/978-3-540-73589-2_2},
file = {:Users/jack/Desktop/FYP-citations/gradual-obj.pdf:pdf},
isbn = {978-3-540-73588-5, 978-3-540-73589-2},
issn = {03029743},
journal = {ECOOP 2007 - Object-Oriented Programming},
pages = {2--27},
title = {{Gradual Typing for Objects}},
url = {http://portal.acm.org/citation.cfm?id=1420964},
year = {2007}
}
@misc{nodejs,
title = {{Node.js}},
url = {https://nodejs.org/en/},
urldate = {2016-03-24},
year = {2009}
}
@article{Damas1982,
abstract = {An abstract is not available.},
author = {Damas, Luis and Milner, Robin},
doi = {10.1145/582153.582176},
file = {:Users/jack/Library/Application Support/Mendeley Desktop/Downloaded/76e1cf37ae212298802799c2c3588030d20a769f.pdf:pdf},
isbn = {0897910656},
issn = {01406736},
journal = {Proceedings of the 9th ACM SIGPLAN-SIGACT symposium on Principles of programming languages - POPL '82},
number = {October},
pages = {207--212},
title = {{Principal type-schemes for functional programs}},
url = {http://portal.acm.org/citation.cfm?doid=582153.582176},
year = {1982}
}
@article{Siek2006,
abstract = {for Functional Languages Jeremy G.  University of Colorado @ cs. colorado. edu Walid Taha Rice University taha@ rice. edu Abstract Static and dynamic type systems have well-known strengths and weaknesses, and each is better suited for different },
author = {Siek, J and Taha, W},
file = {:Users/jack/Desktop/FYP-citations/siek06-{\_}gradual.pdf:pdf},
journal = {Scheme and Functional Programming},
keywords = {optional type annotations,static and dynamic typing},
pages = {81--92},
title = {{Gradual typing for functional languages}},
url = {http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.63.5562{\&}rep=rep1{\&}type=pdf{\#}page=81$\backslash$npapers://cff96cb1-96b7-4b11-a3e3-f4947c1d45b9/Paper/p3505},
year = {2006}
}
@article{Cardelli1987,
abstract = {This paper is largely concerned with implicit polymorphism; it is nonetheless important to dedicate the rest of this section to the relationships between the two kinds of parametric polymorphism.},
author = {Cardelli, Luca},
doi = {10.1016/0167-6423(87)90019-0},
file = {:Users/jack/Library/Application Support/Mendeley Desktop/Downloaded/d46252a5015db1a3f57960c111a99d6dd6f5a5a1.pdf:pdf},
issn = {01676423},
journal = {Science of Computer Programming},
number = {2},
pages = {147--172},
title = {{Basic polymorphic typechecking}},
url = {http://lucacardelli.name/Papers/BasicTypechecking.pdf},
volume = {8},
year = {1987}
}
@article{Hutton1996,
abstract = {In functional programming, a popular approach to building recursive descent parsers is to model parsers as functions, and to define higher-order functions (or combinators) that implement grammar constructions such as sequencing, choice, and repetition. Such parsers form an instance of a monad, an algebraic structure from mathematics that has proved useful for addressing a number of computational problems. The purpose of this report is to provide a step-by-step tutorial on the monadic approach to building functional parsers, and to explain some of the benefits that result from exploiting monads. No prior knowledge of parser combinators or of monads is assumed. Indeed, this report can also be viewed as a first introduction to the use of monads in programming.},
author = {Hutton, Graham and Meijer, Erik},
doi = {10.1017/S0956796800001908},
file = {:Users/jack/Library/Application Support/Mendeley Desktop/Downloaded/95ce15a7890e5620195a36162e3eda82505ac1a4.pdf:pdf},
issn = {0956-7968},
journal = {Journal of Functional Programming},
number = {4},
pages = {437--444},
title = {{Monadic Parser Combinators}},
url = {http://eprints.nottingham.ac.uk/237/},
volume = {8},
year = {1996}
}
@article{unrealengine,
author = {Mozilla},
file = {:Users/jack/Library/Application Support/Mendeley Desktop/Downloaded/9cf3e43f654fb5113f98da2bc764ac0587116956.html:html},
title = {{Mozilla and Epic Preview Unreal Engine 4 Running in Firefox}},
url = {https://blog.mozilla.org/blog/2014/03/12/mozilla-and-epic-preview-unreal-engine-4-running-in-firefox/},
year = {2013}
}
@article{Hindley1969,
author = {Hindley, R},
issn = {00029947},
journal = {Transactions of the American Mathematical Society},
pages = {29--60},
publisher = {American Mathematical Society},
title = {{The Principal Type-Scheme of an Object in Combinatory Logic}},
url = {http://www.jstor.org/stable/1995158},
volume = {146},
year = {1969}
}
@inproceedings{Thatte1989,
address = {New York, NY, USA},
author = {Thatte, Satish},
booktitle = {Proceedings of the 17th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
doi = {10.1145/96709.96747},
isbn = {0-89791-343-4},
pages = {367--381},
publisher = {ACM},
series = {POPL '90},
title = {{Quasi-static Typing}},
url = {http://doi.acm.org/10.1145/96709.96747},
year = {1990}
}
@inproceedings{Swamy:2014:GTE:2535838.2535889,
address = {New York, NY, USA},
author = {Swamy, Nikhil and Fournet, Cedric and Rastogi, Aseem and Bhargavan, Karthikeyan and Chen, Juan and Strub, Pierre-Yves and Bierman, Gavin},
booktitle = {Proceedings of the 41st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
doi = {10.1145/2535838.2535889},
isbn = {978-1-4503-2544-8},
keywords = {compilers,language-based security,type systems},
pages = {425--437},
publisher = {ACM},
series = {POPL '14},
title = {{Gradual Typing Embedded Securely in JavaScript}},
url = {http://doi.acm.org/10.1145/2535838.2535889},
year = {2014}
}
@article{Zakai,
author = {Zakai, Alon},
file = {:Users/jack/Library/Application Support/Mendeley Desktop/Downloaded/0ab24dda560e79160a8d41bee4e6e9f37a6a554e.pdf:pdf},
pages = {1--12},
title = {{Emscripten : An LLVM-to-JavaScript Compiler}},
url = {http://davideglintine-new.googlecode.com/hg/docs/paper.pdf},
year = {2011}
}
@article{Milner1978,
abstract = {The aim of this work is largely a practical one. A widely employed style of programming, particularly in structure-processing languages which impose no discipline of types, entails defining procedures which work well on objects of a wide variety. We present a formal type discipline for such polymorphic procedures in the context of a simple programming language, and a compile time type-checking algorithm W which enforces the discipline. A Semantic Soundness Theorem (based on a formal semantics for the language) states that well-type programs cannot "go wrong" and a Syntactic Soundness Theorem states that if W accepts a program then it is well typed. We also discuss extending these results to richer languages; a type-checking algorithm based on W is in fact already implemented and working, for the metalanguage ML in the Edinburgh LCF system. ?? 1978.},
author = {Milner, Robin},
doi = {10.1016/0022-0000(78)90014-4},
file = {:Users/jack/Library/Application Support/Mendeley Desktop/Downloaded/99f25f223340bc2ea3d1439fc978acb5539070b8.pdf:pdf},
isbn = {1600220000},
issn = {10902724},
journal = {Journal of Computer and System Sciences},
number = {3},
pages = {348--375},
title = {{A theory of type polymorphism in programming}},
url = {https://courses.engr.illinois.edu/cs421/sp2012/project/milner-polymorphism.pdf},
volume = {17},
year = {1978}
}
@article{Chugh2012,
abstract = {We present Dependent JavaScript (DJS), a statically typed dialect of the imperative, object-oriented, dynamic language. DJS supports the particularly challenging features such as run-time type-tests, higher-order functions, extensible objects, prototype inheritance, and arrays through a combination of nested refinement types, strong updates to the heap, and heap unrolling to precisely track prototype hierarchies. With our implementation of DJS, we demonstrate that the type system is expressive enough to reason about a variety of tricky idioms found in small examples drawn from several sources, including the popular book JavaScript: The Good Parts and the SunSpider benchmark suite.},
archivePrefix = {arXiv},
arxivId = {arXiv:1112.4106v1},
author = {Chugh, Ravi and Herman, David and Jhala, Ranjit},
doi = {10.1145/2398857.2384659},
eprint = {arXiv:1112.4106v1},
isbn = {9781450315616},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
keywords = {arrays,dependently type all values,ioms but in a,javascript,prototype inheritance,purely functional setting,refinement types,strong updates,system d is to,the main insight in,with formulas},
number = {10},
pages = {587},
title = {{Dependent types for JavaScript}},
url = {http://dl.acm.org/citation.cfm?doid=2398857.2384659},
volume = {47},
year = {2012}
}
@article{Gray2008,
author = {Gray, Kathryn E},
file = {:Users/jack/Desktop/FYP-citations/inheritance.pdf:pdf},
isbn = {978-3-540-70591-8},
journal = {Ecoop 2008 - Object-Oriented Programming, Proceedings},
pages = {52--75},
title = {{Safe cross-language inheritance}},
url = {{\textless}Go to ISI{\textgreater}://WOS:000257925100003},
volume = {5142},
year = {2008}
}
@book{field1988functional,
author = {Field, Anthony J and Harrison, Peter G},
publisher = {Addison-Wesley},
title = {{Functional programming}},
year = {1988}
}
@article{Herman2007,
abstract = {The Ecma TC39-TG1 working group is using ML as the specification language for the next generation of JavaScript, the popular programming language for browser-based web applications. This ``definitional interpreter'' serves many purposes: a high-level and readable specification language, an executable and testable specification, a reference implementation, and an aid in driving the design process.We describe the design and specification of JavaScript and our experience so far using Standard ML for this purpose.},
author = {Herman, David and Flanagan, Cormac},
doi = {10.1145/1292535.1292543},
file = {:Users/jack/Desktop/FYP-citations/ml07.pdf:pdf},
isbn = {978-1-59593-676-9},
journal = {ML '07: Proceedings of the 2007 workshop on {\{}ML{\}}},
keywords = {lang/js},
pages = {47--52},
title = {{Status report: specifying JavaScript with ML}},
year = {2007}
}
@article{Ford2006,
abstract = {Packrat parsing is a novel technique for implementing parsers in a lazy functional programming language. A packrat parser provides the power and flexibility of top-down parsing with backtracking and unlimited lookahead, but nevertheless guarantees linear parse time. Any language defined by an LL(k) or LR(k) grammar can be recognized by a packrat parser, in addition to many languages that conventional linear-time algorithms do not support. This additional power simplifies the handling of common syntactic idioms such as the widespread but troublesome longest-match rule, enables the use of sophisticated disambiguation strategies such as syntactic and semantic predicates, provides better grammar composition properties, and allows lexical analysis to be integrated seamlessly into parsing. Yet despite its power, packrat parsing shares the same simplicity and elegance as recursive descent parsing; in fact converting a backtracking recursive descent parser into a linear-time packrat parser often involves only a fairly straightforward structural change. This paper describes packrat parsing informally with emphasis on its use in practical applications, and explores its advantages and disadvantages with respect to the more conventional alternatives.},
archivePrefix = {arXiv},
arxivId = {cs/0603077},
author = {Ford, Bryan},
doi = {10.1145/581478.581483},
eprint = {0603077},
file = {:Users/jack/Library/Application Support/Mendeley Desktop/Downloaded/7559a23f5b779fefb2be8b4850c88387c03ec990.pdf:pdf},
isbn = {1581134878},
issn = {03621340},
journal = {Icfp},
keywords = {all or part of,analysis,backtracking,haskell,lexical,memoization,or,or hard copies of,parser combinators,permission to make digital,scannerless parsing,this work for personal,top-down parsing},
pages = {12},
primaryClass = {cs},
title = {{Packrat Parsing: Simple, Powerful, Lazy, Linear Time}},
url = {http://arxiv.org/abs/cs/0603077},
year = {2006}
}
@article{Fink1997,
abstract = {The goal of software testing analysis is to validate that an implementation satisfies its specifications. Many errors in software are caused by generalizable flaws in the source code. Property-based testing assures that a given program is free of specified generic flaws. Property-based testing uses prop- erty specifications and a data-flow analysis of the program to guide evaluation of test ezecutions for correctness and com- pleteness.},
author = {Fink, George and Bishop, Matt},
file = {:Users/jack/Library/Application Support/Mendeley Desktop/Downloaded/8b1f371310de3e237a994be89393373e27126593.pdf:pdf},
journal = {Software Engineering Notes},
number = {4},
pages = {74},
title = {{Property-Based Testing ; A New Approach to Testing for Assurance}},
url = {http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.93.5559{\&}rep=rep1{\&}type=pdf},
volume = {22},
year = {1997}
}
@book{Crockford2008,
abstract = {Most programming languages contain good and bad parts, but JavaScript has more than its share of the bad, having been developed and released in a hurry before it could be refined. This authoritative book scrapes away these bad features to reveal a subset of JavaScript that's more reliable, readable, and maintainable than the language as a whole-a subset you can use to create truly extensible and efficient code. Considered the JavaScript expert by many people in the development community, author Douglas Crockford identifies the abundance of good ideas that make JavaScript an outstanding object-oriented programming language-ideas such as functions, loose typing, dynamic objects, and an expressive object literal notation. Unfortunately, these good ideas are mixed in with bad and downright awful ideas, like a programming model based on global variables. When Java applets failed, JavaScript became the language of the Web by default, making its popularity almost completely independent of its qualities as a programming language. In JavaScript: The Good Parts, Crockford finally digs through the steaming pile of good intentions and blunders to give you a detailed look at all the genuinely elegant parts of JavaScript, including: Syntax Objects Functions Inheritance Arrays Regular expressions Methods Style Beautiful features The real beauty? As you move ahead with the subset of JavaScript that this book presents, you'll also sidestep the need to unlearn all the bad parts. Of course, if you want to find out more about the bad parts and how to use them badly, simply consult any other JavaScript book. With JavaScript: The Good Parts, you'll discover a beautiful, elegant, lightweight and highly expressive language that lets you create effective code, whether you're managing object libraries or just trying to get Ajax to run fast. If you develop sites or applications for the Web, this book is an absolute must.},
archivePrefix = {arXiv},
arxivId = {arXiv:1011.1669v3},
author = {Crockford, Douglas},
booktitle = {Online},
doi = {10.1241/johokanri.44.584},
eprint = {arXiv:1011.1669v3},
isbn = {9780596517748},
issn = {08203946},
pages = {153},
pmid = {9988578},
title = {{JavaScript: The Good Parts}},
volume = {44},
year = {2008}
}
@article{Anderson2005,
abstract = {Object-oriented scripting languages like JavaScript and Python are popular partly because of their dynamic features. These in- clude the runtime modification of objects and classes through addition of fields or updating of methods. These features make static typing dif- ficult and so usually dynamic typing is used. Consequently, errors such as access to non-existent members are not detected until runtime. We first develop a formalism for an object based language, JS0, with features from JavaScript, including dynamic addition of fields and up- dating of methods. We give an operational semantics and static type system for JS0 using structural types. Our types allow objects to evolve in a controlled manner by classifying members as definite or potential. We define a type inference algorithm for JS0 that is sound with respect to the type system. If the type inference algorithm succeeds, then the program is typeable. Therefore, programmers can benefit from the safety offered by the type system, without the need to write explicitly types in their programs.},
author = {Anderson, Christopher and Giannini, Paola and Drossopoulou, Sophia},
doi = {10.1007/11531142},
file = {:Users/jack/Desktop/FYP-citations/typeinferenceforjavascript-ecoop.pdf:pdf},
isbn = {978-3-540-27992-1},
issn = {03029743},
journal = {ECOOP 2005-Object-Oriented},
pages = {428--452},
title = {{Towards type inference for JavaScript}},
url = {http://link.springer.com/chapter/10.1007/11531142{\_}19},
year = {2005}
}
